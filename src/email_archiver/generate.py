"""Auto-generate mbsync and notmuch configuration files from config.toml."""

from __future__ import annotations

import os
import re
from pathlib import Path

from email_archiver.config import PASSWORD_FILE, Config
from email_archiver.runner import run_command


def _sanitize_name(name: str) -> str:
    """Sanitize a folder name for use as an mbsync channel identifier."""
    return re.sub(r"[^a-zA-Z0-9_-]", "-", name).strip("-")


def generate_mbsyncrc(config: Config) -> str:
    """Generate mbsyncrc content from the unified config.

    Produces one IMAPAccount / IMAPStore / MaildirStore / Channel-per-folder /
    Group per configured account.  Password is read from the fixed secrets file.
    """
    assert config.paths is not None
    lines: list[str] = ["# Auto-generated by email-archiver — do not edit manually\n"]

    for acct_name, acct in config.accounts.items():
        maildir_base = config.paths.maildir_root / acct_name

        # IMAPAccount
        lines.append(f"IMAPAccount {acct_name}")
        lines.append(f"Host {acct.imap_host}")
        lines.append(f"User {acct.imap_user}")
        lines.append(f'PassCmd "cat {PASSWORD_FILE}"')
        lines.append(f"TLSType {acct.tls_type}")
        lines.append("CertificateFile /etc/ssl/certs/ca-certificates.crt")
        lines.append("")

        # IMAPStore
        lines.append(f"IMAPStore {acct_name}-remote")
        lines.append(f"Account {acct_name}")
        lines.append("")

        # MaildirStore
        lines.append(f"MaildirStore {acct_name}-local")
        lines.append("SubFolders Verbatim")
        lines.append(f"Path {maildir_base}/")
        lines.append(f"Inbox {maildir_base}/INBOX/")
        lines.append("")

        # One channel per folder
        channel_names: list[str] = []
        for folder in acct.folders:
            chan = f"{acct_name}-{_sanitize_name(folder)}"
            channel_names.append(chan)

            lines.append(f"Channel {chan}")
            lines.append(f'Far :{acct_name}-remote:"{folder}"')
            lines.append(f"Near :{acct_name}-local:{_sanitize_name(folder)}")
            lines.append("Create Near")
            lines.append("Expunge None")
            lines.append("SyncState *")
            lines.append("")

        # Group
        lines.append(f"Group {acct_name}")
        for chan in channel_names:
            lines.append(f"Channel {chan}")
        lines.append("")

    return "\n".join(lines)


def generate_notmuch_config(config: Config) -> str:
    """Generate notmuch configuration content from the unified config.

    Uses the first account's identity for the [user] section.
    """
    assert config.paths is not None

    # Use first account for user identity
    first_acct = next(iter(config.accounts.values()))

    lines = [
        "# Auto-generated by email-archiver — do not edit manually",
        "",
        "[database]",
        f"path={config.paths.maildir_root}",
        "",
        "[user]",
        f"name={first_acct.imap_user}",
        f"primary_email={first_acct.email}",
        "",
        "[new]",
        "tags=unread;inbox;",
        "ignore=.mbsyncstate;.uidvalidity;",
        "",
        "[search]",
        "exclude_tags=deleted;spam;",
        "",
        "[maildir]",
        "synchronize_flags=true",
        "",
    ]
    return "\n".join(lines)


def write_generated_configs(config: Config) -> tuple[Path, Path]:
    """Write auto-generated mbsyncrc and notmuch config to the state directory.

    Returns:
        (mbsyncrc_path, notmuch_config_path)
    """
    assert config.paths is not None
    gen_dir = config.paths.generated_config_dir
    gen_dir.mkdir(parents=True, exist_ok=True)

    mbsyncrc_path = gen_dir / "mbsyncrc"
    mbsyncrc_path.write_text(generate_mbsyncrc(config), encoding="utf-8")

    notmuch_config_path = gen_dir / "notmuch-config"
    notmuch_config_path.write_text(generate_notmuch_config(config), encoding="utf-8")

    return mbsyncrc_path, notmuch_config_path


def ensure_notmuch_init(config: Config, notmuch_config_path: Path) -> None:
    """Idempotently initialize the notmuch database if it does not exist.

    Checks for ``<maildir_root>/.notmuch/`` and runs ``notmuch new`` only when
    the directory is absent.
    """
    assert config.paths is not None
    db_dir = config.paths.maildir_root / ".notmuch"
    if db_dir.is_dir():
        return  # already initialized

    # Ensure the maildir root exists so notmuch new doesn't fail
    config.paths.maildir_root.mkdir(parents=True, exist_ok=True)

    env = {**os.environ, "NOTMUCH_CONFIG": str(notmuch_config_path)}
    result = run_command(["notmuch", "new"], env=env)
    if not result.ok:
        print(f"Warning: notmuch init failed (exit {result.exit_code}): {result.stderr[:300]}")
    else:
        print("Initialized notmuch database.")
